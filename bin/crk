#!/usr/bin/env bash
set -euo pipefail

# crk - Claude Rules Keeper CLI
# Manage context backups and task tracking for Claude Code

readonly VERSION="1.3.0"
readonly GUARD_DIR="${HOME}/.claude/rules-keeper"
readonly BACKUPS_DIR="${GUARD_DIR}/backups"
readonly TASK_FILE="${GUARD_DIR}/current-task.md"
readonly STATE_FILE="${GUARD_DIR}/state.json"
readonly CONFIG_FILE="${GUARD_DIR}/config.json"
readonly HOOKS_DIR="${HOME}/.claude/hooks"
readonly RULES_FILE="${GUARD_DIR}/rules.md"
readonly SESSION_RULES_FILE="${GUARD_DIR}/session-rules.md"
readonly PROJECTS_DIR="${GUARD_DIR}/projects"

# --- Colors ---

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

# --- JSON Helpers ---

json_read() {
    local file="$1"
    local field="$2"
    local default="${3:-}"

    if [[ ! -f "${file}" ]]; then
        echo "${default}"
        return
    fi

    local value=""
    if command -v jq &>/dev/null; then
        value=$(jq -r ".${field} // \"\"" "${file}" 2>/dev/null) || value=""
    elif command -v python3 &>/dev/null; then
        value=$(CRK_FILE="${file}" CRK_FIELD="${field}" python3 -c "
import json, os
try:
    with open(os.environ['CRK_FILE']) as f:
        d = json.load(f)
    keys = os.environ['CRK_FIELD'].split('.')
    v = d
    for k in keys:
        v = v.get(k, '')
    print(v if v is not None else '')
except Exception:
    print('')
" 2>/dev/null) || value=""
    fi

    if [[ -z "${value}" || "${value}" == "null" ]]; then
        echo "${default}"
    else
        echo "${value}"
    fi
}

json_write() {
    local file="$1"
    local key="$2"
    local value="$3"
    local tmp="${file}.tmp.$$"

    if command -v jq &>/dev/null; then
        if [[ "${value}" =~ ^[0-9]+$ ]]; then
            jq ".${key} = ${value}" "${file}" > "${tmp}" 2>/dev/null && mv "${tmp}" "${file}"
        elif [[ "${value}" == "true" || "${value}" == "false" ]]; then
            jq ".${key} = ${value}" "${file}" > "${tmp}" 2>/dev/null && mv "${tmp}" "${file}"
        else
            jq --arg v "${value}" ".${key} = \$v" "${file}" > "${tmp}" 2>/dev/null && mv "${tmp}" "${file}"
        fi
    elif command -v python3 &>/dev/null; then
        CRK_FILE="${file}" CRK_KEY="${key}" CRK_VAL="${value}" CRK_TMP="${tmp}" python3 -c "
import json, os
with open(os.environ['CRK_FILE']) as f:
    d = json.load(f)
val = os.environ['CRK_VAL']
if val.isdigit():
    val = int(val)
elif val in ('true', 'false'):
    val = val == 'true'
d[os.environ['CRK_KEY']] = val
with open(os.environ['CRK_TMP'], 'w') as f:
    json.dump(d, f, indent=2)
" 2>/dev/null && mv "${tmp}" "${file}"
    else
        echo -e "${RED}Error: jq or python3 required to update config${RESET}" >&2
        return 1
    fi
}

# --- Helpers ---

time_ago() {
    local timestamp="$1"
    if [[ -z "${timestamp}" || "${timestamp}" == "null" ]]; then
        echo "never"
        return
    fi

    local epoch=0
    if command -v python3 &>/dev/null; then
        epoch=$(CRK_TS="${timestamp}" python3 -c "
from datetime import datetime
import os
try:
    dt = datetime.fromisoformat(os.environ['CRK_TS'])
    print(int(dt.timestamp()))
except Exception:
    print(0)
" 2>/dev/null) || epoch=0
    elif date --version &>/dev/null 2>&1; then
        epoch=$(date -d "${timestamp}" "+%s" 2>/dev/null) || epoch=0
    else
        epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${timestamp}" "+%s" 2>/dev/null) || epoch=0
    fi

    if [[ "${epoch}" -eq 0 ]]; then
        echo "unknown"
        return
    fi

    local now
    now=$(date "+%s")
    local diff=$((now - epoch))

    if [[ "${diff}" -lt 60 ]]; then
        echo "${diff}s ago"
    elif [[ "${diff}" -lt 3600 ]]; then
        echo "$((diff / 60))m ago"
    elif [[ "${diff}" -lt 86400 ]]; then
        echo "$((diff / 3600))h ago"
    else
        echo "$((diff / 86400))d ago"
    fi
}

check_hook() {
    local hook_name="$1"
    local hook_path="${HOOKS_DIR}/${hook_name}.sh"

    if [[ -f "${hook_path}" && -x "${hook_path}" ]]; then
        echo -e "${GREEN}[OK]${RESET}"
    elif [[ -f "${hook_path}" ]]; then
        echo -e "${YELLOW}[NOT EXEC]${RESET}"
    else
        echo -e "${RED}[MISSING]${RESET}"
    fi
}

get_task_summary() {
    if [[ ! -f "${TASK_FILE}" ]]; then
        echo "(not set)"
        return
    fi

    local objective
    objective=$(grep -m1 "^Objective:" "${TASK_FILE}" 2>/dev/null | sed 's/^Objective:[[:space:]]*//' | head -c 60) || objective=""

    if [[ -z "${objective}" || "${objective}" == "(not set)" ]]; then
        echo "(not set)"
    else
        echo "\"${objective}\""
    fi
}

json_valid() {
    local file="$1"
    if command -v jq &>/dev/null; then
        jq '.' "${file}" &>/dev/null && return 0
    elif command -v python3 &>/dev/null; then
        CRK_FILE="${file}" python3 -c "import json,os; json.load(open(os.environ['CRK_FILE']))" &>/dev/null && return 0
    else
        # Heuristic fallback: check opening and closing braces
        grep -q '^{' "${file}" 2>/dev/null && grep -q '}' "${file}" 2>/dev/null && return 0
    fi
    return 1
}

# --- Commands ---

cmd_status() {
    echo -e "${BOLD}claude-rules-keeper v${VERSION}${RESET}"
    echo "==========================="

    local last_compaction
    last_compaction=$(json_read "${STATE_FILE}" "last_compaction" "")
    local last_type
    last_type=$(json_read "${STATE_FILE}" "last_compaction_type" "")
    local total
    total=$(json_read "${STATE_FILE}" "total_compactions" "0")
    local max_backups
    max_backups=$(json_read "${CONFIG_FILE}" "max_backups" "10")

    local backup_count=0
    if [[ -d "${BACKUPS_DIR}" ]]; then
        backup_count=$(find "${BACKUPS_DIR}" -maxdepth 1 -name "*.md" -type f 2>/dev/null | wc -l | tr -d ' ')
    fi

    local time_str
    time_str=$(time_ago "${last_compaction}")

    local compaction_display="never"
    if [[ -n "${last_compaction}" && "${last_compaction}" != "null" ]]; then
        local display_date
        display_date=$(echo "${last_compaction}" | sed 's/T/ /' | cut -c1-16)
        compaction_display="${display_date} (${last_type}) - ${time_str}"
    fi

    echo -e "Last compaction:  ${compaction_display}"
    echo -e "Total compactions: ${total}"
    echo -e "Backups stored:   ${backup_count}/${max_backups}"
    echo -e "Current task:     $(get_task_summary)"
    echo -e "Hooks:            pre-compact $(check_hook "pre-compact")  session-start $(check_hook "session-start")"
}

cmd_task() {
    if [[ ! -f "${TASK_FILE}" ]]; then
        echo -e "${DIM}No task file found. Run 'crk task set' to create one.${RESET}"
        return
    fi
    cat "${TASK_FILE}"
}

cmd_task_set() {
    mkdir -p "${GUARD_DIR}"

    if [[ ! -t 0 ]]; then
        # Reading from stdin/pipe
        cat > "${TASK_FILE}"
        echo -e "${GREEN}Task updated from stdin.${RESET}"
    elif [[ -n "${EDITOR:-}" ]]; then
        if [[ ! -f "${TASK_FILE}" ]]; then
            cat > "${TASK_FILE}" <<'TMPL'
# Current Task

Objective: (not set)
Key files: (none)
Decisions made: (none)
Last action: (none)
Next step: (none)

---
Updated: (never)
TMPL
        fi
        "${EDITOR}" "${TASK_FILE}"
        echo -e "${GREEN}Task updated.${RESET}"
    else
        echo -e "${YELLOW}No \$EDITOR set and no stdin pipe detected.${RESET}"
        echo "Usage: echo 'my task' | crk task set"
        echo "   or: EDITOR=nano crk task set"
        return 1
    fi
}

cmd_task_clear() {
    cat > "${TASK_FILE}" <<'EOF'
# Current Task

Objective: (not set)
Key files: (none)
Decisions made: (none)
Last action: (none)
Next step: (none)

---
Updated: (never)
EOF
    echo -e "${GREEN}Task cleared to template.${RESET}"
}

cmd_backups() {
    if [[ ! -d "${BACKUPS_DIR}" ]]; then
        echo -e "${DIM}No backups directory found.${RESET}"
        return
    fi

    local files
    files=$(find "${BACKUPS_DIR}" -maxdepth 1 -name "*.md" -type f 2>/dev/null | sort -r)

    if [[ -z "${files}" ]]; then
        echo -e "${DIM}No backups found.${RESET}"
        return
    fi

    echo -e "${BOLD}Backups:${RESET}"
    local i=1
    while IFS= read -r file; do
        local name
        name=$(basename "${file}" .md)
        local display_date
        display_date=$(echo "${name}" | sed 's/_/ /' | sed 's/-/:/3' | sed 's/-/:/3')
        echo -e "  ${DIM}${i}.${RESET} ${display_date}"
        i=$((i + 1))
    done <<< "${files}"
}

cmd_backups_show() {
    if [[ ! -d "${BACKUPS_DIR}" ]]; then
        echo -e "${DIM}No backups directory found.${RESET}"
        return
    fi

    local latest
    latest=$(find "${BACKUPS_DIR}" -maxdepth 1 -name "*.md" -type f 2>/dev/null | sort -r | head -n 1)

    if [[ -z "${latest}" ]]; then
        echo -e "${DIM}No backups found.${RESET}"
        return
    fi

    echo -e "${BOLD}Latest backup:${RESET} $(basename "${latest}")"
    echo "---"
    cat "${latest}"
}

cmd_restore() {
    if [[ ! -d "${BACKUPS_DIR}" ]]; then
        echo -e "${RED}No backups directory found.${RESET}"
        return 1
    fi

    local latest
    latest=$(find "${BACKUPS_DIR}" -maxdepth 1 -name "*.md" -type f 2>/dev/null | sort -r | head -n 1)

    if [[ -z "${latest}" ]]; then
        echo -e "${RED}No backups found.${RESET}"
        return 1
    fi

    # Extract task content from backup (everything after "## Current Task" line)
    local task_content
    task_content=$(sed -n '/^## Current Task$/,$ { /^## Current Task$/d; p; }' "${latest}")

    if [[ -n "${task_content}" ]]; then
        echo "${task_content}" > "${TASK_FILE}"
        echo -e "${GREEN}Restored task from: $(basename "${latest}")${RESET}"
    else
        echo -e "${YELLOW}Backup found but no task content to restore.${RESET}"
    fi
}

cmd_config() {
    if [[ ! -f "${CONFIG_FILE}" ]]; then
        echo -e "${DIM}No config file found.${RESET}"
        return
    fi

    echo -e "${BOLD}Configuration:${RESET}"
    if command -v jq &>/dev/null; then
        jq '.' "${CONFIG_FILE}"
    else
        cat "${CONFIG_FILE}"
    fi
}

cmd_config_set() {
    local key="${1:-}"
    local value="${2:-}"

    if [[ -z "${key}" || -z "${value}" ]]; then
        echo -e "${RED}Usage: crk config set <key> <value>${RESET}"
        echo "Available keys: max_backups, language, auto_confirm_after_compact, backup_transcript"
        return 1
    fi

    if [[ ! -f "${CONFIG_FILE}" ]]; then
        echo -e "${RED}Config file not found. Run install first.${RESET}"
        return 1
    fi

    json_write "${CONFIG_FILE}" "${key}" "${value}"
    echo -e "${GREEN}Set ${key} = ${value}${RESET}"
}

count_rules() {
    local file="$1"
    if [[ ! -f "${file}" ]]; then
        echo "0"
        return
    fi
    local n
    n=$(grep -c "^- " "${file}" 2>/dev/null) || true
    echo "${n:-0}"
}

cmd_rules() {
    local project_name
    project_name=$(basename "$(git rev-parse --show-toplevel 2>/dev/null || pwd)")
    local project_rules_file="${PROJECTS_DIR}/${project_name}/rules.md"

    local session_count
    session_count=$(count_rules "${SESSION_RULES_FILE}")
    local global_count
    global_count=$(count_rules "${RULES_FILE}")
    local project_count
    project_count=$(count_rules "${project_rules_file}")

    echo -e "${BOLD}Active Rules${RESET}"
    echo ""

    # Session rules
    echo -e "${DIM}── Session (${session_count}) ─────────────────────${RESET}"
    if [[ "${session_count}" -gt 0 ]]; then
        grep "^- " "${SESSION_RULES_FILE}" 2>/dev/null
    else
        echo -e "${DIM}  (none)${RESET}"
    fi
    echo ""

    # Global rules
    echo -e "${DIM}── Global (${global_count}) ──────────────────────${RESET}"
    if [[ "${global_count}" -gt 0 ]]; then
        grep "^- " "${RULES_FILE}" 2>/dev/null
    else
        echo -e "${DIM}  (none)${RESET}"
    fi
    echo ""

    # Project rules
    echo -e "${DIM}── Project: ${project_name} (${project_count}) ───${RESET}"
    if [[ "${project_count}" -gt 0 ]]; then
        grep "^- " "${project_rules_file}" 2>/dev/null
    else
        echo -e "${DIM}  (none)${RESET}"
    fi
}

cmd_presets() {
    local presets_dir="${GUARD_DIR}/presets"

    if [[ ! -d "${presets_dir}" ]]; then
        echo -e "${DIM}No presets directory found.${RESET}"
        return
    fi

    local files
    files=$(find "${presets_dir}" -maxdepth 1 -name "*.md" -type f 2>/dev/null | sort)

    if [[ -z "${files}" ]]; then
        echo -e "${DIM}No presets saved. Use /rules-save <name> to create one.${RESET}"
        return
    fi

    echo -e "${BOLD}Saved Presets${RESET}"
    echo ""
    while IFS= read -r file; do
        local name
        name=$(basename "${file}" .md)
        local rule_count
        rule_count=$(grep -c "^- " "${file}" 2>/dev/null) || true
        local created
        created=$(grep -m1 "^Created:" "${file}" 2>/dev/null | sed 's/^Created:[[:space:]]*//')
        created="${created:-unknown}"
        echo -e "  ${BOLD}${name}${RESET}  ${DIM}(${rule_count:-0} rules, ${created})${RESET}"
    done <<< "${files}"
}

cmd_doctor() {
    local pass=0
    local total=0
    local settings_file="${HOME}/.claude/settings.json"
    local claude_md="${HOME}/.claude/CLAUDE.md"
    local skill_file="${HOME}/.claude/skills/rules-keeper/SKILL.md"

    doctor_check() {
        local label="$1"
        local result="$2"
        total=$((total + 1))
        if [[ "${result}" == "ok" ]]; then
            pass=$((pass + 1))
            echo -e "  ${GREEN}[OK]${RESET}   ${label}"
        elif [[ "${result}" == "warn" ]]; then
            echo -e "  ${YELLOW}[WARN]${RESET} ${label}"
        else
            echo -e "  ${RED}[FAIL]${RESET} ${label}"
        fi
    }

    echo -e "${BOLD}crk doctor${RESET}"
    echo "=========="

    # 1. Rules-keeper directory
    if [[ -d "${GUARD_DIR}" ]]; then
        doctor_check "Rules-keeper directory" "ok"
    else
        doctor_check "Rules-keeper directory" "fail"
    fi

    # 2. Backups directory
    if [[ -d "${BACKUPS_DIR}" ]]; then
        doctor_check "Backups directory" "ok"
    else
        doctor_check "Backups directory" "fail"
    fi

    # 3. PreCompact hook
    if [[ -f "${HOOKS_DIR}/pre-compact.sh" && -x "${HOOKS_DIR}/pre-compact.sh" ]]; then
        doctor_check "PreCompact hook (executable)" "ok"
    elif [[ -f "${HOOKS_DIR}/pre-compact.sh" ]]; then
        doctor_check "PreCompact hook (not executable)" "warn"
    else
        doctor_check "PreCompact hook" "fail"
    fi

    # 4. SessionStart hook
    if [[ -f "${HOOKS_DIR}/session-start.sh" && -x "${HOOKS_DIR}/session-start.sh" ]]; then
        doctor_check "SessionStart hook (executable)" "ok"
    elif [[ -f "${HOOKS_DIR}/session-start.sh" ]]; then
        doctor_check "SessionStart hook (not executable)" "warn"
    else
        doctor_check "SessionStart hook" "fail"
    fi

    # 5. settings.json: PreCompact registered
    if [[ -f "${settings_file}" ]] && grep -q "pre-compact.sh" "${settings_file}" 2>/dev/null; then
        doctor_check "settings.json: PreCompact registered" "ok"
    else
        doctor_check "settings.json: PreCompact registered" "fail"
    fi

    # 6. settings.json: SessionStart (compact matcher)
    if [[ -f "${settings_file}" ]] && grep -q '"matcher"' "${settings_file}" 2>/dev/null && grep -q "session-start.sh" "${settings_file}" 2>/dev/null; then
        doctor_check "settings.json: SessionStart (compact)" "ok"
    else
        doctor_check "settings.json: SessionStart (compact)" "fail"
    fi

    # 7. settings.json: SessionStart (cleanup — two entries for session-start.sh)
    local ss_count=0
    if [[ -f "${settings_file}" ]]; then
        ss_count=$(grep -c "session-start.sh" "${settings_file}" 2>/dev/null) || ss_count=0
    fi
    if [[ "${ss_count}" -ge 2 ]]; then
        doctor_check "settings.json: SessionStart (cleanup)" "ok"
    else
        doctor_check "settings.json: SessionStart (cleanup)" "fail"
    fi

    # 8. CLAUDE.md guard markers
    if [[ -f "${claude_md}" ]] && grep -q "CLAUDE-RULES-KEEPER:START" "${claude_md}" 2>/dev/null; then
        doctor_check "CLAUDE.md guard markers" "ok"
    else
        doctor_check "CLAUDE.md guard markers" "fail"
    fi

    # 9. Skill installed
    if [[ -f "${skill_file}" ]]; then
        doctor_check "Skill rules-keeper installed" "ok"
    else
        doctor_check "Skill rules-keeper installed" "fail"
    fi

    # 10. crk in PATH
    if command -v crk &>/dev/null; then
        doctor_check "crk in PATH" "ok"
    else
        doctor_check "crk in PATH" "fail"
    fi

    # 11. rules.md
    if [[ -f "${RULES_FILE}" ]]; then
        doctor_check "rules.md exists" "ok"
    else
        doctor_check "rules.md exists" "fail"
    fi

    # 12. config.json valid
    if [[ -f "${CONFIG_FILE}" ]] && json_valid "${CONFIG_FILE}"; then
        doctor_check "config.json valid" "ok"
    else
        doctor_check "config.json valid" "fail"
    fi

    # 13. state.json valid
    if [[ -f "${STATE_FILE}" ]] && json_valid "${STATE_FILE}"; then
        doctor_check "state.json valid" "ok"
    else
        doctor_check "state.json valid" "fail"
    fi

    echo ""
    if [[ "${pass}" -eq "${total}" ]]; then
        echo -e "${GREEN}${pass}/${total} checks passed${RESET}"
    else
        echo -e "${YELLOW}${pass}/${total} checks passed${RESET}"
    fi
}

cmd_upgrade() {
    local repo_url="https://raw.githubusercontent.com/sanztheo/claude-rules-keeper/main"

    echo -e "${BOLD}Checking for updates...${RESET}"

    local remote_version=""
    remote_version=$(curl -fsSL "${repo_url}/bin/crk" 2>/dev/null | grep -m1 'readonly VERSION=' | sed 's/.*"\(.*\)".*/\1/') || true

    if [[ -z "${remote_version}" ]]; then
        echo -e "${RED}Could not fetch remote version. Check your internet connection.${RESET}"
        return 1
    fi

    echo -e "  Local:  v${VERSION}"
    echo -e "  Remote: v${remote_version}"
    echo ""

    if [[ "${VERSION}" == "${remote_version}" ]]; then
        echo -e "${GREEN}Already up to date (v${VERSION})${RESET}"
        return 0
    fi

    echo -n "Upgrade to v${remote_version}? [y/N] "
    local answer=""
    if [[ -t 0 ]]; then
        read -r answer
    else
        answer="y"
        echo "y (non-interactive)"
    fi

    if [[ "${answer}" != "y" && "${answer}" != "Y" ]]; then
        echo -e "${DIM}Upgrade cancelled.${RESET}"
        return 0
    fi

    echo -e "Upgrading v${VERSION} → v${remote_version}..."
    curl -fsSL "${repo_url}/install.sh" | bash
}

cmd_help() {
    echo -e "${BOLD}claude-rules-keeper v${VERSION}${RESET}"
    echo ""
    echo "Usage: crk <command> [args]"
    echo ""
    echo -e "${BOLD}Commands:${RESET}"
    echo "  rules           Show all active rules (session + global + project)"
    echo "  presets         List saved rule presets"
    echo "  status          Current state: last compaction, task, backups, hooks"
    echo "  task            Show current task"
    echo "  task set        Set current task (opens \$EDITOR or reads stdin)"
    echo "  task clear      Clear current task to template"
    echo "  backups         List all backups with timestamps"
    echo "  backups show    Show most recent backup"
    echo "  restore         Copy latest backup to current-task.md"
    echo "  config          Show config"
    echo "  config set K V  Update config value"
    echo "  doctor          Run diagnostic checks on installation"
    echo "  upgrade         Check for updates and upgrade"
    echo "  help            Show this help"
    echo "  version         Print version"
    echo ""
    echo -e "${DIM}Files: ~/.claude/rules-keeper/${RESET}"
}

cmd_version() {
    echo "claude-rules-keeper v${VERSION}"
}

# --- Main Router ---

main() {
    local cmd="${1:-help}"
    local subcmd="${2:-}"

    case "${cmd}" in
        rules)
            cmd_rules
            ;;
        presets)
            cmd_presets
            ;;
        status)
            cmd_status
            ;;
        task)
            case "${subcmd}" in
                set)    cmd_task_set ;;
                clear)  cmd_task_clear ;;
                "")     cmd_task ;;
                *)      echo -e "${RED}Unknown task subcommand: ${subcmd}${RESET}"; cmd_help; return 1 ;;
            esac
            ;;
        backups)
            case "${subcmd}" in
                show)   cmd_backups_show ;;
                "")     cmd_backups ;;
                *)      echo -e "${RED}Unknown backups subcommand: ${subcmd}${RESET}"; cmd_help; return 1 ;;
            esac
            ;;
        restore)
            cmd_restore
            ;;
        config)
            case "${subcmd}" in
                set)    cmd_config_set "${3:-}" "${4:-}" ;;
                "")     cmd_config ;;
                *)      echo -e "${RED}Unknown config subcommand: ${subcmd}${RESET}"; cmd_help; return 1 ;;
            esac
            ;;
        doctor)
            cmd_doctor
            ;;
        upgrade)
            cmd_upgrade
            ;;
        help|--help|-h)
            cmd_help
            ;;
        version|--version|-v)
            cmd_version
            ;;
        *)
            echo -e "${RED}Unknown command: ${cmd}${RESET}"
            cmd_help
            return 1
            ;;
    esac
}

main "$@"
